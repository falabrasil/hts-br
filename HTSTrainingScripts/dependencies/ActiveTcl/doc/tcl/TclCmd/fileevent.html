<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>ActiveTcl 8.6.7 Documentation</title>
    <meta name="generator" content="Hugo 0.30.2" />

    
    <meta name="description" content="Complete documentation for ActiveTcl 8.6.7">
    
    <link rel="canonical" href="fileevent.html">
    

    
    <meta name="apple-mobile-web-app-title" content="ActiveTcl 8.6.7 Documentation">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="../../images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="../../images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('../../fonts/icon.eot');
        src: url('../../fonts/icon.eot')
               format('embedded-opentype'),
             url('../../fonts/icon.woff')
               format('woff'),
             url('../../fonts/icon.ttf')
               format('truetype'),
             url('../../fonts/icon.svg')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="../../stylesheets/application.css">
    <link rel="stylesheet" href="../../stylesheets/temporary.css">
    <link rel="stylesheet" href="../../stylesheets/palettes.css">
    <link rel="stylesheet" href="../../stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open%20Sans:400,700|Source+Code+Pro">
    <style>
      body, input {
        font-family: 'Open Sans', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Source Code Pro', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <link rel="stylesheet" href="../../stylesheets/as_common.css">
    
    <link rel="stylesheet" href="../../stylesheets/as_custom.css">
    
    <script src="../../javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-grey palette-accent-red">




<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="logo">
        <a href="http://www.activestate.com/">
          <img src="../../images/logo.png" alt="ActiveState homepage">
        </a>
      </div>
      <div class="title">
        
        
        
        
        <a href="http://docs.activestate.com/">docs.activestate.com</a>
      </div>
    </div>

    

    

    
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>

</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="../../index.html" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="../../images/as_tcl.png">
        </div>
      
      <div class="name">
        <strong>ActiveTcl 8.6.7 Documentation </strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      

      <div class="toc">
        
        <ul>
          




<li>
  



<a  title="Get ActiveTcl" href="../../get/index.html">
	
	Get ActiveTcl
</a>



  
    <ul>
      
        
        



<a  title="Release notes" href="../../get/relnotes/index.html">
	
	Release notes
</a>



      
        
        



<a  title="Windows installation" href="../../get/windows/index.html">
	
	Windows installation
</a>



      
        
        



<a  title="Linux/Unix Installaton" href="../../get/linux/index.html">
	
	Linux/Unix Installaton
</a>



      
        
        



<a  title="macOS Installation" href="../../get/macos/index.html">
	
	macOS Installation
</a>



      
        
        



<a  title="License" href="../../get/license/index.html">
	
	License
</a>



      
    </ul>
  
</li>



<li>
  



<a  title="Get Started" href="../../start/index.html">
	
	Get Started
</a>



  
    <ul>
      
        
        



<a  title="Package Reference" href="../../pkg/index.html">
	
	Package Reference
</a>



      
        
        



<a  title="Tcl 8.6.7 docs" href="../contents.html">
	
	Tcl 8.6.7 docs
</a>



      
    </ul>
  
</li>



<li>
  



<a  title="Contact Us" href="../../contact/index.html">
	
	Contact Us
</a>



  
</li>


        </ul>
        

        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1> </h1>

			<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD><TITLE>fileevent manual page - Tcl Built-In Commands</TITLE>
<link rel="stylesheet" href="../docs.css" type="text/css" media="all">
</HEAD>
<BODY><H2><a href="../contents.html">Tcl8.6.7/Tk8.6.7 Documentation</a> <small>&gt;</small> <a href="contents.html">Tcl Commands, version 8.6.7</a> <small>&gt;</small> fileevent</H2>
<H3><A HREF="../UserCmd/contents.html">Tcl/Tk Applications</A> | <A HREF="contents.html">Tcl Commands</A> | <A HREF="../TkCmd/contents.html">Tk Commands</A> | <A HREF="../ItclCmd/contents.html">[incr Tcl] Package Commands</A> | <A HREF="../SqliteCmd/contents.html">SQLite3 Package Commands</A> | <A HREF="../TdbcCmd/contents.html">TDBC Package Commands</A> | <A HREF="../TdbcmysqlCmd/contents.html">tdbc::mysql Package Commands</A> | <A HREF="../TdbcodbcCmd/contents.html">tdbc::odbc Package Commands</A> | <A HREF="../TdbcpostgresCmd/contents.html">tdbc::postgres Package Commands</A> | <A HREF="../TdbcsqliteCmd/contents.html">tdbc::sqlite3 Package Commands</A> | <A HREF="../ThreadCmd/contents.html">Thread Package Commands</A> | <A HREF="../TclLib/contents.html">Tcl C API</A> | <A HREF="../TkLib/contents.html">Tk C API</A> | <A HREF="../ItclLib/contents.html">[incr Tcl] Package C API</A> | <A HREF="../TdbcLib/contents.html">TDBC Package C API</A></H3>
<H3><A NAME="M2">NAME</A></H3>
fileevent &mdash; Execute a script when a channel becomes readable or writable
<H3><A NAME="M3">SYNOPSIS</A></H3>
<B>fileevent </B><I>channelId </I><B>readable </B>?<I>script</I>?<BR>
<B>fileevent </B><I>channelId </I><B>writable </B>?<I>script</I>?<BR>
<H3><A NAME="M4">DESCRIPTION</A></H3>
This command is used to create <I>file event handlers</I>.  A file event
handler is a binding between a channel and a script, such that the script
is evaluated whenever the channel becomes readable or writable.  File event
handlers are most commonly used to allow data to be received from another
process on an event-driven basis, so that the receiver can continue to
interact with the user while waiting for the data to arrive.  If an
application invokes <B><A HREF="gets.html">gets</A></B> or <B><A HREF="read.html">read</A></B> on a blocking channel when
there is no input data available, the process will block; until the input
data arrives, it will not be able to service other events, so it will
appear to the user to
&#8220;freeze up&#8221;.
With <B>fileevent</B>, the process can
tell when data is present and only invoke <B><A HREF="gets.html">gets</A></B> or <B><A HREF="read.html">read</A></B> when
they will not block.
<P>
The <I>channelId</I> argument to <B>fileevent</B> refers to an open
channel such as a Tcl standard channel (<B><A HREF="../TclLib/GetStdChan.html">stdin</A></B>, <B><A HREF="../TclLib/GetStdChan.html">stdout</A></B>,
or <B><A HREF="../TclLib/GetStdChan.html">stderr</A></B>), the return value from an invocation of <B><A HREF="open.html">open</A></B>
or <B><A HREF="socket.html">socket</A></B>, or the result of a channel creation command provided
by a Tcl extension.
<P>
If the <I>script</I> argument is specified, then <B>fileevent</B>
creates a new event handler:  <I>script</I> will be evaluated
whenever the channel becomes readable or writable (depending on the
second argument to <B>fileevent</B>).
In this case <B>fileevent</B> returns an empty string.
The <B>readable</B> and <B>writable</B> event handlers for a file
are independent, and may be created and deleted separately.
However, there may be at most one <B>readable</B> and one <B>writable</B>
handler for a file at a given time in a given interpreter.
If <B>fileevent</B> is called when the specified handler already
exists in the invoking interpreter, the new script replaces the old one.
<P>
If the <I>script</I> argument is not specified, <B>fileevent</B>
returns the current script for <I>channelId</I>, or an empty string
if there is none.
If the <I>script</I> argument is specified as an empty string
then the event handler is deleted, so that no script will be invoked.
A file event handler is also deleted automatically whenever
its channel is closed or its interpreter is deleted.
<P>
A channel is considered to be readable if there is unread data
available on the underlying device.
A channel is also considered to be readable if there is unread
data in an input buffer, except in the special case where the
most recent attempt to read from the channel was a <B><A HREF="gets.html">gets</A></B>
call that could not find a complete line in the input buffer.
This feature allows a file to be read a line at a time in nonblocking mode
using events.
A channel is also considered to be readable if an end of file or
error condition is present on the underlying file or device.
It is important for <I>script</I> to check for these conditions
and handle them appropriately;  for example, if there is no special
check for end of file, an infinite loop may occur where <I>script</I>
reads no data, returns, and is immediately invoked again.
<P>
A channel is considered to be writable if at least one byte of data
can be written to the underlying file or device without blocking,
or if an error condition is present on the underlying file or device.
<P>
Event-driven I/O works best for channels that have been placed into
nonblocking mode with the <B><A HREF="fconfigure.html">fconfigure</A></B> command.  In blocking mode,
a <B><A HREF="puts.html">puts</A></B> command may block if you give it more data than the
underlying file or device can accept, and a <B><A HREF="gets.html">gets</A></B> or <B><A HREF="read.html">read</A></B>
command will block if you attempt to read more data than is ready; a
readable underlying file or device may not even guarantee that a
blocking [read 1] will succeed (counter-examples being multi-byte
encodings, compression or encryption transforms ). In all such cases,
no events will be processed while the commands block.
<P>
In nonblocking mode <B><A HREF="puts.html">puts</A></B>, <B><A HREF="read.html">read</A></B>, and <B><A HREF="gets.html">gets</A></B> never block.
See the documentation for the individual commands for information
on how they handle blocking and nonblocking channels.
<P>
Testing for the end of file condition should be done after any attempts
read the channel data. The eof flag is set once an attempt to read the
end of data has occurred and testing before this read will require an
additional event to be fired.
<P>
The script for a file event is executed at global level (outside the
context of any Tcl procedure) in the interpreter in which the
<B>fileevent</B> command was invoked.
If an error occurs while executing the script then the
command registered with <B><A HREF="interp.html">interp bgerror</A></B> is used to report the error.
In addition, the file event handler is deleted if it ever returns
an error;  this is done in order to prevent infinite loops due to
buggy handlers.
<H3><A NAME="M5">EXAMPLE</A></H3>
In this setup <B>GetData</B> will be called with the channel as an
argument whenever $chan becomes readable. The <B><A HREF="read.html">read</A></B> call will
read whatever binary data is currently available without blocking.
Here the channel has the fileevent removed when an end of file
occurs to avoid being continually called (see above). Alternatively
the channel may be closed on this condition.
<P>
<PRE>proc GetData {chan} {
    set data [read $chan]
    puts &quot;[string length $data] $data&quot;
    if {[eof $chan]} {
        fileevent $chan readable {}
    }
}

fconfigure $chan -blocking 0 -encoding binary
<B>fileevent</B> $chan readable [list GetData $chan]</PRE>
<P>
The next example demonstrates use of <B><A HREF="gets.html">gets</A></B> to read line-oriented
data.
<P>
<PRE>proc GetData {chan} {
    if {[gets $chan line] &gt;= 0} {
        puts $line
    }
    if {[eof $chan]} {
        close $chan
    }
}

fconfigure $chan -blocking 0 -buffering line -translation crlf
<B>fileevent</B> $chan readable [list GetData $chan]</PRE>
<H3><A NAME="M6">CREDITS</A></H3>
<B>fileevent</B> is based on the <B>addinput</B> command created
by Mark Diekhans.
<H3><A NAME="M7">SEE ALSO</A></H3>
<B><A HREF="fconfigure.html">fconfigure</A></B>, <B><A HREF="gets.html">gets</A></B>, <B><A HREF="interp.html">interp</A></B>, <B><A HREF="puts.html">puts</A></B>, <B><A HREF="read.html">read</A></B>, <B><A HREF="../TclLib/StdChannels.html">Tcl_StandardChannels</A></B>
<H3><A NAME="M8">KEYWORDS</A></H3>
<A href="../Keywords/A.html#asynchronous I/O">asynchronous I/O</A>, <A href="../Keywords/B.html#blocking">blocking</A>, <A href="../Keywords/C.html#channel">channel</A>, <A href="../Keywords/E.html#event handler">event handler</A>, <A href="../Keywords/N.html#nonblocking">nonblocking</A>, <A href="../Keywords/R.html#readable">readable</A>, <A href="../Keywords/S.html#script">script</A>, <A href="../Keywords/W.html#writable.">writable.</A>
<div class="copy">Copyright &copy; 1994 The Regents of the University of California.
<BR>Copyright &copy; 1994-1996 Sun Microsystems, Inc.
<BR>Copyright &copy; 2008 Pat Thoyts
</div>
</BODY></HTML>


			<aside class="copyright" role="note">
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				<div class="as_footer">
  
  <div class="prod_links">
    <strong>
    <a href="http://www.activestate.com/downloads" target="_blank">Downloads</a>&nbsp;&nbsp;
    <a href="http://store.activestate.com" target="_blank">Store</a>&nbsp;&nbsp;
    <a href="http://community.activestate.com" target="_blank">Community</a>&nbsp;&nbsp;
    <a href="http://code.activestate.com" target="_blank">Code</a>&nbsp;&nbsp;
    <a href="http://bugs.activestate.com" target="_blank">Bugzilla</a>
  </strong>
  </div>
  <div class="as_copyright"> 
    &copy; 2017 ActiveState Software Inc. All rights reserved. <strong><a href="../../trademarks/index.html">Trademarks</a></strong>.
  </div>
</div>

			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '';
      var repo_id  = '';
    
    </script>

    <script src="../../javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "Â¶";
            headers[i].appendChild(a);
        }
      }
    </script>

    

    

  </body>
</html>

