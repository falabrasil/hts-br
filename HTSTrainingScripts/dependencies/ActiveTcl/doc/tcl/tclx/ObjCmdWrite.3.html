<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>ActiveTcl 8.6.7 Documentation</title>
    <meta name="generator" content="Hugo 0.30.2" />

    
    <meta name="description" content="Complete documentation for ActiveTcl 8.6.7">
    
    <link rel="canonical" href="ObjCmdWrite.3.html">
    

    
    <meta name="apple-mobile-web-app-title" content="ActiveTcl 8.6.7 Documentation">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="../../images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="../../images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('../../fonts/icon.eot');
        src: url('../../fonts/icon.eot')
               format('embedded-opentype'),
             url('../../fonts/icon.woff')
               format('woff'),
             url('../../fonts/icon.ttf')
               format('truetype'),
             url('../../fonts/icon.svg')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="../../stylesheets/application.css">
    <link rel="stylesheet" href="../../stylesheets/temporary.css">
    <link rel="stylesheet" href="../../stylesheets/palettes.css">
    <link rel="stylesheet" href="../../stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open%20Sans:400,700|Source+Code+Pro">
    <style>
      body, input {
        font-family: 'Open Sans', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Source Code Pro', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <link rel="stylesheet" href="../../stylesheets/as_common.css">
    
    <link rel="stylesheet" href="../../stylesheets/as_custom.css">
    
    <script src="../../javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-grey palette-accent-red">




<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="logo">
        <a href="http://www.activestate.com/">
          <img src="../../images/logo.png" alt="ActiveState homepage">
        </a>
      </div>
      <div class="title">
        
        
        
        
        <a href="http://docs.activestate.com/">docs.activestate.com</a>
      </div>
    </div>

    

    

    
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>

</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="../../index.html" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="../../images/as_tcl.png">
        </div>
      
      <div class="name">
        <strong>ActiveTcl 8.6.7 Documentation </strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      

      <div class="toc">
        
        <ul>
          




<li>
  



<a  title="Get ActiveTcl" href="../../get/index.html">
	
	Get ActiveTcl
</a>



  
    <ul>
      
        
        



<a  title="Release notes" href="../../get/relnotes/index.html">
	
	Release notes
</a>



      
        
        



<a  title="Windows installation" href="../../get/windows/index.html">
	
	Windows installation
</a>



      
        
        



<a  title="Linux/Unix Installaton" href="../../get/linux/index.html">
	
	Linux/Unix Installaton
</a>



      
        
        



<a  title="macOS Installation" href="../../get/macos/index.html">
	
	macOS Installation
</a>



      
        
        



<a  title="License" href="../../get/license/index.html">
	
	License
</a>



      
    </ul>
  
</li>



<li>
  



<a  title="Get Started" href="../../start/index.html">
	
	Get Started
</a>



  
    <ul>
      
        
        



<a  title="Package Reference" href="../../pkg/index.html">
	
	Package Reference
</a>



      
        
        



<a  title="Tcl 8.6.7 docs" href="../contents.html">
	
	Tcl 8.6.7 docs
</a>



      
    </ul>
  
</li>



<li>
  



<a  title="Contact Us" href="../../contact/index.html">
	
	Contact Us
</a>



  
</li>


        </ul>
        

        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1> </h1>

			<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- manual page source format generated by PolyglotMan v3.0.8+X.Org, -->
<!-- available at http://polyglotman.sourceforge.net/ -->
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta name='Author' content='ActiveState'>

<title>TclX ObjCmdWrite</title>
</head>
<body>
<a href='ObjCmdWrite.3.html#toc'>Table of Contents</a> 

<h2><a name='sect0' href='ObjCmdWrite.3.html#toc0'>Name</a></h2>

<p>TclCommandWriting - Writing C language extensions to Tcl.</p>

<h2><a name='sect1' href='ObjCmdWrite.3.html#toc1'><b>Overview</b></a></h2>

<p>This document is intended to help the programmer who wishes to
extend Tcl with C language routines. It should also be useful to
someone wishing to add Tcl to an existing editor, communications
program, win-dow manager, etc. Experienced extension writers may
find this manual helpful in rewriting their applications to use the
new Tcl object sys-tem. We assume you are already fluent in the C
programming language and that you have built and installed Tcl on
your machine.</p>

<p>Information on the available C interface routines to Tcl can be
found in the <i>*.3</i> manual pages in the <i>doc</i> directory of
the baseline Tcl dis-tribution, and in the <i>*.3</i> manpages in
the <i>doc</i> directory of Extended Tcl.</p>

<h2><a name='sect2' href='ObjCmdWrite.3.html#toc2'><b>Tcl</b> <b>Object</b>
<b>System</b></a></h2>

<p>With the release of Tcl version 8, Tcl has a new system for
managing Tcl values internally. To the Tcl programmer, the new
objects look and act like strings, as before. But at the C level,
these objects can now also hold cached internal representations of
the strings in various native datatypes. For example, an object
containing a string consist-ing of an integer, will now maintain a
machine-code integer representa-tion, if an integer representation
has been needed. Using these objects is much more efficient than
using the older-style Tcl strings, although the older style is
still (currently) supported.</p>

<p>Although the object system has almost no effect at all on how
the Tcl programmer uses Tcl, the object system&acirc;&euro;&trade;s
C interfaces to strings, inte-gers, lists, etc., have changed
considerably. While converting a pack-age to use the new system can
be a lot of work, the combination of the object system, which saves
Tcl from having to constantly convert strings to integers and back,
etc., and the on-the-fly bytecode com-piler (which keeps Tcl from
having to continually reparse code it is to execute) yield Tcl
programs that routinely execute several times more quickly than
with previous versions (Tcl 7 and before), and in some cases run as
much as 2500 (!) times faster than before.</p>

<p>We have chosen, then, to rewrite the Command
Writer&acirc;&euro;&trade;s manpage, which has been shipping with
Extended Tcl for a number of years, to produce this new version
based on the new object system. The old manpage, based on the older
string-oriented routines, will still be included in TclX releases
for now, as it is still relevant to Tcl releases through version 7,
and may be of use to those modifying/upgrading packages written for
the old model. The old manual will be dropped from the release once
we deem it unneeded; the old interfaces should now be con-sidered
legacy interfaces, and all new development should be done using the
new object interfaces, unless backwards compatibility to pre-Tcl-8
releases is needed.</p>

<h2><a name='sect3' href='ObjCmdWrite.3.html#toc3'><b>a</b> <b>Simple</b> <b>C</b>
<b>Extension</b></a></h2>

<p>All C-based Tcl commands are called with four arguments: a
client data pointer, an interpreter pointer, an argument count and
a pointer to an array of Tcl objects containing the arguments to
the command.</p>

<p>A simple C extension to Tcl is now presented, and described
below:</p>

<p>#include tcl.h"</p>

<p>int App_DumpArgsObjCmd(clientData, interp, objc, objv)</p>

<dl>
<dt>void</dt>

<dd>*clientData;</dd>

<dt>Tcl_Interp</dt>

<dd>*interp;</dd>

<dt>int</dt>

<dd>objc;</dd>

<dt>Tcl_Obj</dt>

<dd>**objv; { int i; int stringLen; char *stringPtr;</dd>
</dl>

<p>for (i = 1; i &lt; objc; i++) { stringPtr = Tcl_GetStringFromObj
(objv [i], &amp;stringLen); printf("%s", stringPtr); if (i &lt;
objc - 1) printf( ); }<br>
 printf("\n");<br>
 return TCL_OK;<br>
 }</p>

<p>The client data pointer will be described later.</p>

<h2><a name='sect4' href='ObjCmdWrite.3.html#toc4'><b>Interpreters</b></a></h2>

<p>The interpreter pointer is the
&acirc;&euro;&tilde;&acirc;&euro;&tilde;key&acirc;&euro;&trade;&acirc;&euro;&trade;
to an interpreter. It is returned by <b>Tcl_CreateInterp</b> and is
used extensively within Tcl, and will be used by your C extensions.
The data structure pointed to by the interpreter pointer, and all
of the subordinate structures that branch off of it, make up a Tcl
interpreter, which includes all of the currently defined
procedures, commands, variables, arrays and the exe-cution state of
that interpreter. (For more information on creating and deleting
interpreters, please examine the <a href=
'http://localhost:1313/tcl/tclx/CrtInterp.3.html'>CrtInterp(3)</a> manpage in the core Tcl
distribution. For information on creating interpreters that include
the commands provided by Extended Tcl, check out the <a href=
'http://localhost:1313/tcl/tclx/TclX_Init.3.html'>TclX_Init(3)</a> manpage of Extended Tcl. For a
manual page describing the user-visible fields of a Tcl
interpreter, please look at <a href='http://localhost:1313/tcl/tclx/Interp.3.html'>Interp(3)</a>
in core Tcl.)</p>

<h2><a name='sect5' href='ObjCmdWrite.3.html#toc5'><b>Object</b> <b>Count</b>
<b>and</b> <b>Arguments</b></a></h2>

<p>The argument count, or object count (objc), and pointer to an
array of pointers to Tcl objects of the
command&acirc;&euro;&trade;s arguments (objv) is handled by your C
code, in a manner similar to the one you would use in writing a C
<i>main</i> function -- an argument count and array of pointers
works the same as in a C <i>main</i> call; pointers to the
arguments to the function are contained in the <i>objv</i> array.
Similar to a C main, the first argument (<i>objv[0]</i>) is an
object containing the name the routine was called as (in a C main,
the name the program was invoked as).</p>

<p>In Tcl, however, the array of pointers are not pointers to
character strings (although they were in all version of Tcl before
8.0).</p>

<p>In the above example, all of the arguments are output with a
space between each one by looping through elements of the
<i>objv</i> array from one to the argument count, <i>objc</i>, and
a newline is output to terminate the line -- a simple
&acirc;&euro;&tilde;&acirc;&euro;&tilde;echo&acirc;&euro;&trade;&acirc;&euro;&trade;
command. This example uses printf for sim-plicity. Of course in
production code you would want to use the Tcl filesystem
interfaces. See <a href='http://localhost:1313/tcl/tclx/GetFile.3.html'>GetFile(3)</a> and friends
for more informa-tion.</p>

<p>All arguments from a Tcl call to a Tcl C extension are passed as
Tcl Objects. If your C routine wants to look at one of those
arguments as an integer, you need to make a call to a routine to
fetch the represen-tation of the object that you need. In the
earlier example, for instance, <b>Tcl_GetStringFromObj</b> is
called to obtain a textual represen-tation of an object. Additional
routines are available to fetch the representation of a data
element as other data types. Tcl_GetBoolean-FromObj,
Tcl_GetDoubleFromObj, Tcl_GetIntFromObj, Tcl_GetLongFromObj, and
Tcl_GetIndexFromObj, fetch object representations of Tcl strings as
booleans, double-precision floating point, integer, long integer,
and lists, among others.</p>

<p>These routines automatically leave an appropriate error message
in the Tcl interpreter&acirc;&euro;&trade;s result object and
return <b>TCL_ERROR</b> if a conversion error occurs. (For more
information on these routines, please look at the <a href=
'http://localhost:1313/tcl/tclx/Object.3.html'>Object(3)</a> manpage in the core Tcl
distribution.)</p>

<h2><a name='sect6' href='ObjCmdWrite.3.html#toc6'><b>Returning</b>
<b>Results</b></a></h2>

<p>As you might expect, the API for setting results from C
extensions has changed significantly under the object system. The
old technique of writing small results directory into the
interpreter&acirc;&euro;&trade;s result buffer is no longer used,
for example. The notion of having to tell Tcl whether a result is
static or dynamic is also a thing of the past. Under the object
system, results are objects that are set up by your code, and
objects are freed when their reference counts say they should be.
More on this later.</p>

<p>If you program produces a numeric result, it should set the
result object to contain that numeric value. A common way of doing
this is something like...</p>

<p>Tcl_Obj *obj;</p>

<p>obj = Tcl_GetObjResult (interp); Tcl_SetIntObj (obj, value);</p>

<p>The above code obtains a pointer to the result object (an object
made available to your routine that you&acirc;&euro;&trade;re
supposed to store your results into) and sets the integer value
<i>value</i> into it.</p>

<p>Another way to do it would be to set up a new object and tell
Tcl that this object contains the result...</p>

<p>Tcl_Obj *resultObj;</p>

<p>/* create a new object for use as a result */ resultObj =
Tcl_NewObj ();</p>

<p>Tcl_SetIntObj (obj, value);<br>
 Tcl_SetObjResult (interp, resultObj);</p>

<p>Understanding how results are passed back to Tcl is essential to
the C extension writer. Please study the <a href=
'http://localhost:1313/tcl/tclx/SetObjResult.3.html'>SetObjResult(3)</a> manual page in the Tcl
distribution for more information.</p>

<h2><a name='sect7' href='ObjCmdWrite.3.html#toc7'><b>Validating</b>
<b>Arguments</b></a></h2>

<p>It is a design goal of Tcl that no Tcl program be able to cause
Tcl to dump core. It is important that the extension writers,
likewise, use the avaiable methods and tools to make sure that
their extensions do not allow unchecked input, for example, to
cause the code to get some kind of runtime exception.</p>

<p>The object system has simplified, to some degree, the task of
validat-ing arguments, in that the object system automatically
attempts type conversions as needed, and will return an error when
a type conversion fails.</p>

<p>A simple, but important, check that every C extension should do
is ver-ify that it has the right number of arguments.</p>

<p>The act of trying to use, say, a string as an integer,
implicitly per-forms the type conversion of the string and, if it
doesn&acirc;&euro;&trade;t work as an integer, returns TCL_ERROR.
The developer should check for the TCL_ERROR return from all of the
GetXxxFromObj commands, and handle them as appropriate. Usually
this will mean propagating the error on back to the user, or to an
intevening catch, as the case may be.</p>

<p>You should also check that values are in range (when their
ranges are known), and so forth. When C data structures need to be
handled in Tcl in some form or another, yet the contents of the
data must remain opaque to Tcl, as is usually the case with binary
data (although futures releases of Tcl are expected to have native
abilities to read, write and manipulate binary data
instrinsically), <i>handles</i> need to be used. Handles will be
described and examples presented, later in this doc.</p>

<h2><a name='sect8' href='ObjCmdWrite.3.html#toc8'><b>Another</b> <b>C</b>
<b>Extension</b> <b>-</b> <b>the</b> <b>Max</b>
<b>Command</b></a></h2>

<p>In the command below, two or more arguments are compared, and
the one with the maximum value is returned, if all goes well. It is
an error if there are fewer than two arguments (the pointer to the
&acirc;&euro;&tilde;&acirc;&euro;&tilde;max&acirc;&euro;&trade;&acirc;&euro;&trade;
com-mand text itself, <i>objv[0]</i>, and a pointer to at least one
object to com-pare the values of).</p>

<p>int<br>
 Tcl_MaxCmd (clientData, interp, objc, objv)</p>

<dl>
<dt>char</dt>

<dd>*clientData; Tcl_Interp *interp;</dd>

<dt>int</dt>

<dd>objc;</dd>

<dt>Tcl_Obj</dt>

<dd>**objv; { int maxVal = MININT; int value, idx;</dd>
</dl>

<p>if (objc &lt; 3)<br>
 return TclX_WrongArgs (interp, objv[0], num1 num2 [..numN]");</p>

<p>for (idx = 1; idx &lt; objc; idx++) { if (Tcl_GetIntFromObj
(interp, objv[idx], &amp;value) != TCL_OK) return TCL_ERROR;</p>

<p>if (value &gt; maxVal) {<br>
 maxVal = value;<br>
 }<br>
 }<br>
 Tcl_SetIntObj (Tcl_GetObjResult (interp), value); return
TCL_OK;<br>
 }</p>

<p>Here we introduce the Extended Tcl helper function
<b>TclX_WrongArgs</b>. This routine makes it easy to create an
error message and error return in response to the common mistake of
being called with a wrong number.</p>

<p><b>Tcl_GetIntFromObj</b> is used to fetch the integer values of
the remaining arguments. If any fail to be converted, we return a
Tcl error. If an interpreter is specified in the call to
<b>Tcl_GetIntFromObj</b>, an appropri-ate error message about the
conversion failure will be left in the result, so we do that
here.</p>

<p>After examining all of the arguments to find the largest value,
we set the result object to contain that value, and return
<b>TCL_OK</b>.</p>

<h2><a name='sect9' href='ObjCmdWrite.3.html#toc9'><b>Returning</b>
<b>Results</b></a></h2>

<p>When Tcl-callable functions complete, they should normally
return <b>TCL_OK</b> or <b>TCL_ERROR</b>. <b>TCL_OK</b> is returned
when the command succeeded, and <b>TCL_ERROR</b> is returned when
the command has failed in some abnormal way. <b>TCL_ERROR</b>
should be returned for all syntax errors, non-numeric values when
numeric ones were expected, and so forth. Less clear in some cases
is whether Tcl errors should be returned or whether a func-tion
should just return a status value. For example, end-of-file dur-ing
a <i>gets</i> returns a status, but <i>open</i> returns an error if
it fails. Errors can be caught from Tcl programs using the
<i>catch</i> command. (See Tcl&acirc;&euro;&trade;s <a href=
'http://localhost:1313/tcl/tclx/catch.n.html'>catch(n)</a> and <a href='http://localhost:1313/tcl/tclx/error.n.html'>error(n)</a>
manual pages.)</p>

<p>Less common return values are <b>TCL_RETURN</b>,
<b>TCL_BREAK</b> and <b>TCL_CONTINUE</b>. These are used if you are
adding new control and/or looping structures to Tcl. To see these
values in action, examine the source code to Extended
Tcl&acirc;&euro;&trade;s <i>loop</i> commands.
Tcl&acirc;&euro;&trade;s <i>while</i>, <i>for</i> and <i>if</i>
commands used to work in the just same manner, but are now compiled
into bytecode by the bytecode for performance.</p>

<h2><a name='sect10' href='ObjCmdWrite.3.html#toc10'><b>Another</b> <b>C</b>
<b>Extension</b> <b>-</b> <b>the</b> <b>Lreverse</b>
<b>Command</b></a></h2>

<p>In the command below, a list is passed as an argument, and a
list con-taining all of the elements of the list in reverse order
is returned. It is an error if anything other than two arguments
are passed (the pointer to the
&acirc;&euro;&tilde;&acirc;&euro;&tilde;lreverse&acirc;&euro;&trade;&acirc;&euro;&trade;
command text itself, <i>objv[0]</i>, and a pointer to the list to
reverse.</p>

<p>Once <i>lreverse</i> has determined that it has received the
correct number of arguments, <b>Tcl_ListObjGetElements</b> is
called to split the list into its own <i>objc</i> count of elements
and <i>objv</i> array of pointers to the list&acirc;&euro;&trade;s
elements.</p>

<p><i>lreverse</i> then operates on the array of pointers, swapping
them from lowest to highest, second-lowest to second-highest, and
so forth.</p>

<p><b>Tcl_ListObjAppendElement</b> is called on successive list
elements to build up the new list, which is finally returned as
result of the command.</p>

<p>int<br>
 Tcl_LreverseObjCmd(notUsed, interp, objc, objv) ClientData
notUsed; /* Not used. */ Tcl_Interp *interp; /* Current
interpreter. */</p>

<dl>
<dt>int</dt>

<dd>objc; /* Number of arguments. */ Tcl_Obj **obj; /* Argument
strings. */ { int listObjc, lowListIndex, hiListIndex; Tcl_Obj
**listObjv; char *temp, *resultList; Tcl_Obj **newListObjv;</dd>
</dl>

<p>/* Verify argument count. Since we take only one argument,
argument * count must be 2 (command plus one argument). */<br>
 if (objc != 2)<br>
 return TclX_WrongArgs (interp, objv [0], list");</p>

<p>/* Create an object to handle the new list
we&acirc;&euro;&trade;re creating */ newListObjv =
Tcl_NewObj();</p>

<p>/* Crack the list at objv[1] into its own count and array of
object * pointers.<br>
 */<br>
 if (Tcl_ListObjGetElements (interp, objv[1], &amp;listObjc,
&amp;listObjv) != TCL_OK) { return TCL_ERROR;<br>
 }</p>

<p>/* For each element in the source list from last to first,
append an * element to the new list.<br>
 */<br>
 for (listIndex = listObjc - 1; listIndex &gt;= 0; listIndex--) {
Tcl_ListObjAppendElement (interp, newListObjv,
listObjv[listIndex]); }<br>
 FIX: NEED TO RETURN THE LIST.<br>
 return TCL_OK;<br>
 }</p>

<h2><a name='sect11' href='ObjCmdWrite.3.html#toc11'><b>Installing</b> <b>Your</b>
<b>Command</b></a></h2>

<p>To install your command into Tcl you must call
<b>Tcl_CreateObjCommand</b>, passing it the pointer to the
interpreter you want to install the com-mand into, the name of the
command, a pointer to the C function that implements the command, a
client data pointer, and a pointer to an optional callback
routine.</p>

<p>The client data pointer and the callback routine will be
described later.</p>

<p>For example, for the max function above (which, incidentally,
comes from TclX&acirc;&euro;&trade;s tclXmath.c in the
<i>TclX7.4/src</i> directory):</p>

<p>Tcl_CreateCommand (interp, max", Tcl_MaxCmd, (ClientData)NULL,
(void (*)())NULL);</p>

<p>In the above example, the max function is added to the specified
inter-preter. The client data pointer and callback function pointer
are NULL. (For complete information on <b>Tcl_CreateCommand</b> and
its companion routine, <b>Tcl_CommandInfo</b>, please examine the
<a href='http://localhost:1313/tcl/tclx/CrtCommand.3.html'>CrtCommand(3)</a> command page in the
core Tcl distribution.)</p>

<h2><a name='sect12' href='ObjCmdWrite.3.html#toc12'><b>Dynamic</b>
<b>Strings</b></a></h2>

<p><i>Dynamic</i> <i>strings</i> are an important abstraction that
first became avail-able with Tcl 7.0. Dynamic strings, or
<i>DStrings</i>, provide a way to build up arbitrarily long strings
through a repeated process of append-ing information to them.
DStrings reduce the amount of allocating and copying required to
add information to a string. Further, they sim-plify the process of
doing so.</p>

<p>At first glance, it may seem that the object system supersedes
DStrings. It does not, in that the performance improvements made
pos-sible by the lazy conversion of an object&acirc;&euro;&trade;s
representation from one datatype to another does not come into play
much while constructing strings as the string representation is
always available either without any type conversion or where type
conversion would be necessary in any case as a string
representation of the object is required when strings are being
constructed by concatenation, etc.</p>

<p>It should be noted, however, that the C level string
manipulation capa-bilites of objects, such as
<b>Tcl_AppendToObj</b> and <b>Tcl_AppendStringsToObj</b>, are often
plenty enough for what you need to do. For complete informa-tion on
dynamic strings, please examine the <a href=
'http://localhost:1313/tcl/tclx/DString.3.html'>DString(3)</a> manual page in the core Tcl
distribution. For more on Tcl object&acirc;&euro;&trade;s
string-oriented calls, seek <a href=
'http://localhost:1313/tcl/tclx/Tcl_StringObj.3.html'>Tcl_StringObj(3)</a> in the same
location.</p>

<h2><a name='sect13' href='ObjCmdWrite.3.html#toc13'><b>Client</b>
<b>Data</b></a></h2>

<p>The client data pointer provides a means for Tcl commands to
have data associated with them that is not global to the C program
nor included in the Tcl core. Client data is essential in a
multi-interpreter envi-ronment (where a single program has created
and is making use of multi-ple Tcl interpreters) for the C routines
to maintain any permanent data they need on a per-interpreter
basis. If needed static data was simply declared static in C, you
will probably have reentrancy problems when you work with multiple
interpreters.</p>

<p>Tcl solves this through the client data mechanism. When you are
about to call <b>Tcl_CreateObjCommand</b> to add a new command to
an interpreter, if your command needs to keep some read/write data
across invocations, you should allocate the space, preferably using
<b>Tcl_Alloc</b> instead of <b>malloc</b>, then pass the address of
that space as the ClientData pointer to
<b>Tcl_CreateObjCommand</b>.</p>

<p>When your command is called from Tcl, the ClientData pointer you
passed to <b>Tcl_CreateObjCommand</b> will be passed to your C
routine through the ClientData pointer calling argument.</p>

<p>Commands that need to share this data with one another can do so
by using the same ClientData pointer when the commands are
added.</p>

<p>It is important to note that the Tcl extensions in the
<i>tclX8.0.0</i> direc-tory have had all of their data set up in
this way. Since release 6.2, Extended Tcl has supported multiple
interpreters within one invocation of Tcl.</p>

<h2><a name='sect14' href='ObjCmdWrite.3.html#toc14'><b>Theory</b> <b>of</b>
<b>Handles</b></a></h2>

<p>Sometimes you need to have a data element that
isn&acirc;&euro;&trade;t readily repre-sentable as a string within
Tcl, for example a pointer to a complex C data structure. It is not
a good idea to try to pass pointers around within Tcl as strings by
converting them to and from hex or integer representations, for
example. It is too easy to mess one up, and the likely outcome of
doing that is a core dump.</p>

<p>Instead we have developed and made use of the concept of
<i>handles</i>. Han-dles are identifiers a C extension can pass to,
and accept from, Tcl to make the transition between what your C
code knows something as and what name Tcl knows it by to be as safe
and painless as possible. For example, the I/O system included in
Tcl uses file handles. When you open a file from Tcl, a handle is
returned of the form <b>file</b><i>n</i> where <i>n</i> is a file
number. When you pass the file handle back to <i>puts</i>,
<i>gets</i>, <i>seek</i>, <i>flush</i> and so forth, they validate
the file handle by checking the the <b>file</b> text is present,
then converting the file number to an integer that they use to look
into a data structure of pointers to Tcl open file structures,
which contain a Unix file descriptor, flags indicating whether or
not the file is currently open, whether the file is a file or a
pipe and so forth.</p>

<p>Handles have proven so useful that, since TclX release 6.1a,
general support has been available to help create and manipulate
them. Many of these capabilities have migrated into baseline Tcl.
If you have a sim-ilar need, you might like to use the handle
routines documented in <a href='http://localhost:1313/tcl/tclx/Han-dles.3.html'>Han-dles(3)</a> in
Extended Tcl. We recommend that you use a unique-to-your-package
textual handle coupled with a specific identifier and let the
handle management routines validate it when it&acirc;&euro;&trade;s
passed back. It is much easier to track down a bug with an
implicated handle named some-thing like <b>file4</b> or
<b>bitmap6</b> than just <b>6</b>.</p>

<p>Note that Tcl&acirc;&euro;&trade;s object offers another way for
complex data structures to exist in parallel with and underneath
Tcl strings. As of this writ-ing (May 30, 1997) this is fairly new
territory, but things are looking good for the prospects of using
the Tcl object system in this manner, and for enhancements to the
object system that allow even Tcl objects to have methods in a very
straightforward and simple way.</p>

<h2><a name='sect15' href='ObjCmdWrite.3.html#toc15'><b>Using</b> <b>Commands</b>
<b>to</b> <b>Do</b> <b>the</b> <b>Same</b> <b>Thing,</b> <b>and</b>
<b>More</b></a></h2>

<p>Another handle-like technique, first popularized in the Tk
toolkit, offers handle-like capabilities as well as some neat
additional capa-bilities. That is to create a new Tcl command, from
C, that uses ClientData to keep a handle on its complex underlying
data structure. Then by having that command look at its second
argument for what it is to do (its sub-functions), you get these
nice methods, where you have several additional sub-commands that
don&acirc;&euro;&trade;t pollute the global namespace and only work
on (and are available with) the objects (new commands) they are
relevant to. For example, in Tk, creating a checkbutton
(<b>checkbutton</b> <b>.b)</b> <b>creates</b> <b>a</b> <b>new</b>
<b>Tcl</b> <b>command</b> <b>(.b),</b> <b>that</b> <b>has</b>
<b>methods</b> <b>to</b> <b>configure</b> <b>the</b> <b>button,</b>
<b>select,</b> <b>deselect,</b> <b>toggle</b> <b>and</b>
<b>flash</b> <b>it.</b></p>

<p>A lot of people think this is really the way to go, and I am
pretty much leaning that way myself. If you use the <b>incr</b>
<b>tcl</b> script-level object system for Tcl, objects that you
define in Tcl will be highly compatible in terms of their command
interfaces and configuration man-agement with objects you create in
C using the the command-and-Client-Data technique described here. I
believe <b>Tk</b> has some nice facilities for making this easy for
the Tcl programmer. <b>Itcl</b> certainly does.</p>

<h2><a name='sect16' href='ObjCmdWrite.3.html#toc16'><b>Tracking</b> <b>Memory</b>
<b>Corruption</b> <b>Problems</b></a></h2>

<p>Occasionally you may write code that scribbles past the end of
an allo-cated piece of memory. This will usually result in a core
dump or mem-ory allocation failure sometime later in the program,
often implicating code that is not actually responsible for the
problem (as you start looking from the point where the error is
detected, which is usually where the later routine has failed).</p>

<p>The memory debugging routines included in Tcl can help find
these prob-lems. Developed by Mark and Karl, the memory debugging
routines are now part of baseline Tcl, and is to our knowledge the
largest piece of TclX to drop into the core without being
reengineered first. (You see, summer back in
&acirc;&euro;&trade;91, John was sitting in his office in the CS
building at UC Berkeley trying to find a memory leak somewhere in
Tcl, when he was paid a visit by two long-haired-yet-polite
programmers bearing gifts in the form of the technology grab-bag
known as Extended Tcl. He saw that, using TclX&acirc;&euro;&trade;s
malloc routines, Tcl could be prompted to print the filename and
line number of every single memory allocation that did not have a
corresponding free. It was just what the doctor ordered ;-) See
<i>Memory(TCL)</i> for details.</p>

<h2><a name='sect17' href='ObjCmdWrite.3.html#toc17'><b>Installing</b> <b>Your</b>
<b>Extensions</b> <b>into</b> <b>Tcl</b></a></h2>

<p>To add your extensions to Tcl, you used to have to statically
link them, together with any other extensions, into a single binary
exe-cutable image. Today, although the statically linked executable
is still an option, most operating systems, even Microsoft Windows,
sup-port shared libraries, and in most cases, Tcl can now make use
of those shared libraries such that you extensions, and most
others, can now be built a shared libraries that can be loaded in
(using <b>package</b> <b>require</b>) by scripts that need them.
Shared libraries can simplify a Tcl instal-lation, because only one
copy of Tcl is required, rather than a hode-podge of combinations
of applications that you might have found at a big Tcl site in the
previous era.</p>

<h2><a name='sect18' href='ObjCmdWrite.3.html#toc18'><b>GNU</b>
<b>Autoconf</b></a></h2>

<p>While the build procedure for shared libraries varies from
system to system, most Unix and Unix workalike systems will figure
out the nuances of the compiler and linker arguments automatically
when the <i>configure</i> script is run. If you are building a
package that you plan to make generally available, we strongly
recommend that you use <b>GNU</b> <b>autoconf</b>
(ftp://prep.ai.mit.edu/pub/gnu) to set up an automatic
<i>config-ure</i> script for it. Be forewarned that <i>autoconf</i>
uses some pretty heavy duty shell and sed script magic to get the
job done, and the learning curve can be pretty steep. Once done and
shaken out, though, it&acirc;&euro;&trade;s rewarding to know that
your package can build and run on everything from a notebook to a
Cray to a RISC SMP server.</p>

<p>Application-specific startup is accomplished by creating or
editing the <i>Tcl</i><b>_</b><i>AppInit</i> function. In
<i>Tcl</i><b>_</b><i>AppInit</i> you should add a call to an
application-specific init function which you create. This function
should take the address of the interpreter it should install its
com-mands into, and it should install those commands with
<b>Tcl_CreateCommand</b> and do any other application-specific
startup that is necessary.</p>

<p>The naming convention for application startup routines is
<b>App_Init</b>, where <i>App</i> is the name of your application.
For example, to add an application named <i>cute</i> one would
create a <i>Cute</i><b>_</b><i>Init</i> routine that expected a
<b>Tcl_Interp</b> pointer as an argument, and add the following
code to <i>Tcl</i><b>_</b><i>AppInit</i>:</p>

<p>if (Cute_Init (interp) == TCL_ERROR) { return TCL_ERROR;<br>
 }</p>

<p>As you can guess from the above example, if your init routine is
unable to initialize, it should use <b>Tcl_AppendResult</b> to
provide some kind of useful error message back to TclX, then return
<b>TCL_ERROR</b> to indicate that an error occurred. If the routine
executed successfully, it should return <b>TCL_OK</b>.</p>

<p>When you examine <i>Tcl</i><b>_</b><i>AppInit</i>, note that
there is one call already there to install an application -- the
call to <i>TclX</i><b>_</b><i>Init</i> installs Extended Tcl into
the Tcl core.</p>

<h2><a name='sect19' href='ObjCmdWrite.3.html#toc19'><b>Making</b> <b>Application</b>
<b>Information</b> <b>Visible</b> <b>from</b> <b>Extended</b>
<b>Tcl</b></a></h2>

<p>TclX&acirc;&euro;&trade;s <b>infox</b> command can return
several pieces of information relevant to Extended Tcl, including
the application&acirc;&euro;&trade;s name, descriptive name, patch
level and version. Your application&acirc;&euro;&trade;s startup
can set these variables to application-specific values. If it
doesn&acirc;&euro;&trade;t, they are given default values for
Extended Tcl.</p>

<p>To set these values, first be sure that you include either
<b>tclExtend.h</b> or <b>tclExtdInt.h</b> from the source file that
defines your init routine. This will create external declarations
for the variables. Then, set the variables in your init route, for
example:</p>

<p>tclAppName = cute";<br>
 tclAppLongName = Call Unix/Tcl Environment"; tclAppVersion =
2.1";</p>

<p>Note that the default values are set by
<i>TclX</i><b>_</b><i>Init</i>, so if you wish to override them,
you must call your init routine in <i>Tcl</i><b>_</b><i>AppInit</i>
after its call to <i>TclX</i><b>_</b><i>Init</i>.</p>

<h2><a name='sect20' href='ObjCmdWrite.3.html#toc20'><b>Extended</b> <b>Tcl</b>
<b>Exit</b></a></h2>

<p>When Extended Tcl exits, <b>Tcl_DeleteInterp</b> may be called
to free memory used by Tcl -- normally, this is only called if
<b>TCL_MEM_DEBUG</b> was defined, since Unix will return all of the
allocated memory back to the system, anyway. If
<b>TCL_MEM_DEBUG</b> was defined, it is called so that any memory
that was allocated without ever being freed can be detected. This
greatly reduces the amount of work to detect and track down memory
leaks, a situation where some piece of your code allocates memory
repeatedly without ever freeing it, or at least without always
freeing it.</p>

<p>It is often necessary for an application to perform special
cleanup functions upon the deletion of an interpreter as well. To
facilitate this activity, Tcl provides the ability to perform a
function callback when an interpreter is deleted. To arrange for a
C function to be called when the interpreter is deleted, call
<b>Tcl_CallWhenDeleted</b> from your application initialization
routine. For details on how to use this function, read the <a href=
'http://localhost:1313/tcl/tclx/CallDel.3.html'>CallDel(3)</a> manual page that ships with core
Tcl.</p>

<h2><a name='sect21' href='ObjCmdWrite.3.html#toc21'><b>Executing</b> <b>Tcl</b>
<b>Code</b> <b>from</b> <b>Your</b> <b>C</b>
<b>Extension</b></a></h2>

<p>Suppose you are in the middle of coding a C extension and you
realize that you need some operation performed, one that would be
simple from Tcl, but possibly excruciating to do directly in C. Tcl
provides a number of C-level interfaces whereby you can cause Tcl
code to be exe-cuteed. The old-style calls are <b>Tcl_Eval</b>,
<b>Tcl_VarEval</b>, <b>Tcl_EvalFile</b> and <b>Tcl_GlobalEval</b>.
The results of these calls can be dug out of the interpreter using
<b>Tcl_GetStringResult</b>, if you want a string representa-tion of
the result, or <b>Tcl_GetObjResult</b> if you want the object. (The
use of <b>interp-&gt;result</b> to access the result string has
been deprecated.)</p>

<p>The Tcl object system adds <b>Tcl_EvalObj</b> and
<b>Tcl_GlobalEvalObj</b>. The dif-ference here is that we are
evaluating an object, not just a string, and using these routines
in preference to the aforementioned ones can result in a major
performance improvement in your code, when the code is executed
repeatedly (even if it only executes once but loops several times
within itself), as these routines make it possible for the
byte-code compiler to compile the code being evaluated and save the
compiled code with the data structure, in an
implementation-dependent manner.</p>

<p>For more information please consult the <a href=
'http://localhost:1313/tcl/tclx/EvalObj.3.html'>EvalObj(3)</a> and <a href=
'http://localhost:1313/tcl/tclx/Eval.3.html'>Eval(3)</a> manual pages within the Tcl
distribution.</p>

<h2><a name='sect22' href='ObjCmdWrite.3.html#toc22'><b>Accessing</b> <b>Tcl</b>
<b>Variables</b> <b>and</b> <b>Arrays</b> <b>from</b> <b>Your</b>
<b>C</b> <b>Extensions</b></a></h2>

<p>In addition to the non-object-system ways of reading from and
storing to Tcl variables, using routines such as <b>Tcl_SetVar2</b>
and <b>Tcl_GetVar2</b>, Tcl variables and arrays can be read from a
C extension as Tcl objects by using the <b>Tcl_ObjGetVar2</b>
function, and set from C extensions through the
<b>Tcl_ObjSetVar2</b> function.</p>

<p>Please note that the object versions do not carry forward
analogues to the one-variable-name-argument <b>Tcl_GetVar</b>,
<b>Tcl_SetVar</b>, and <b>Tcl_Unset-Var</b>. If you know you have a
scalar, call the object variable get and set functions with a NULL
second argument. If your variable name might contain an array
reference via a self-contained embedded array index (i.e.,
I&acirc;&euro;&trade;m asking <b>Tcl_ObjGetVar2</b> for <a href=
'http://localhost:1313/tcl/tclx/foo.5.html'>foo(5)</a> instead of <b>foo</b> <b>5"</b>), add the
<b>TCL_PARSE_PART1</b> to the flags in your call.</p>

<p>While the fact that <b>Tcl_ObjGetVar2</b> retrieves Tcl objects,
rather than strings, is critical for the object system to be able
to provide the performance boosts from lazy type conversion and the
binary data capabilities, the arguments containing the variable
name, or the array name and element name if
they&acirc;&euro;&trade;ve been split out, also must be specified
as Tcl objects rather than strings. While this is useful on
occasion, those writing C extensions for Tcl in the
post-object-system era usu-ally have the names available as plain
old <i>char</i> <i>*</i> variables, requiring conversion of the
strings to objects before use and account for their possible
destruction afterwards.</p>

<p>To simplify the task in those cases, TclX adds the
<b>TclX_ObjGetVar2S</b> subroutine. It works just like
<b>Tcl_ObjGetVar2</b>, except the one or two variable name
arguments are specified as strings, and the routine takes care of
making and disposing of object equivalents.</p>

<p>Tcl variables can be unset from C via the <b>Tcl_UnsetVar</b>
and <b>Tcl_Unset-Var2</b> functions. There are currently (as of
8.0) no object-system equivalents, so in the rare case where you
have the name of the vari-able you want unset as an object instead
of a string, you can call <b>Tcl_GetStringFromObj</b> to obtain the
string representation first.</p>

<p>For complete information on these functions, please refer to the
<a href='http://localhost:1313/tcl/tclx/ObjSetVar.3.html'>ObjSetVar(3)</a> and <a href=
'http://localhost:1313/tcl/tclx/SetVar.3.html'>SetVar(3)</a> manual pages in the <i>doc</i>
directory of the core Tcl distribution.</p>

<h2><a name='sect23' href='ObjCmdWrite.3.html#toc23'><b>Linking</b> <b>Tcl</b>
<b>Variables</b> <b>to</b> <b>C</b> <b>Variables</b></a></h2>

<p><b>Tcl_LinkVar</b> and <b>Tcl_UnlinkVar</b> can be used to
automatically keep Tcl variables synchronized with corresponding C
variables. Once a Tcl variable has been linked to a C variable with
<b>Tcl_LinkVar</b>, anytime the Tcl variable is read, the value of
the C variable is converted (if nec-essary) and returned, and when
the Tcl variable is written, the C vari-able will be updated with
the new value.</p>

<p><b>Tcl_LinkVar</b> uses variable traces to keep the Tcl variable
named by <i>var-Name</i> in sync with the C variable at the address
given by <i>addr</i>.</p>

<p><i>Int</i>, <i>double</i>, <i>boolean</i> and <i>char</i>
<i>*</i> variables are supported. You can make your linked
variables read only from the Tcl side, as well. Please note that
the C variables must continually exist while they are linked, in
other words, linking automatic C variables, those created on the
stack while a routine is being executed and destroyed afterwards,
will result in a malfunctioning program at best and a coredump or
more at worst.</p>

<p>For more information, please examine the <a href=
'http://localhost:1313/tcl/tclx/LinkVar.3.html'>LinkVar(3)</a> manual page in the core Tcl
distribution.</p>

<h2><a name='sect24' href='ObjCmdWrite.3.html#toc24'><b>Adding</b> <b>New</b>
<b>Math</b> <b>Functions</b> <b>to</b> <b>Tcl</b></a></h2>

<p>As of Tcl version 7.0, math functions such as <i>sin</i>,
<i>cos</i>, etc, are directly supported within Tcl expressions.
These obsolete the Extended Tcl commands that provided explicit
commands for these functions for many, many releases, although
procs equivalencing the old TclX commands to the new math functions
are still provided for backwards compatibil-ity.</p>

<p>New math functions can be added to Tcl, or existing math
functions can be replaced, by calling
<b>Tcl_CreateMathFunc</b>.</p>

<h2><a name='sect25' href='ObjCmdWrite.3.html#toc25'><b>Accessing</b> <b>and</b>
<b>Manipulating</b> <b>the</b> <b>Random</b> <b>Number</b>
<b>Generator</b></a></h2>

<p>Prior to Tcl version 8.0, the Tcl core did not provide access to
a ran-dom number generator, but TclX did, through its <i>random</i>
command. As of Tcl version 8.0, access to a random number generator
is provided by baseline Tcl through the new math functions,
<i>rand</i> and <i>srand</i>.</p>

<p>The TclX <i>random</i> command is still available -- it has some
useful capa-bilities not directly provided by the new baseline
functions.</p>

<p>For more information on adding your own math functions to Tcl,
please study the <a href='http://localhost:1313/tcl/tclx/CrtMathFnc.3.html'>CrtMathFnc(3)</a>
manual page in the core Tcl distribution.</p>

<h2><a name='sect26' href='ObjCmdWrite.3.html#toc26'><b>Converting</b>
<b>Filenames</b> <b>to</b> <b>Native</b> <b>Form</b> <b>and</b>
<b>Performing</b> <b>Tilde</b> <b>Substitutions</b></a></h2>

<p>The <b>Tcl_TranslateFileName</b> function is available to C
extension writers to translate filenames to a form suitable for use
by the local operat-ing system. It converts network names to their
native form, and if the name starts with a
&acirc;&euro;&tilde;&acirc;&euro;&tilde;~&acirc;&euro;&trade;&acirc;&euro;&trade;
character, the function returns a new string where the name is
replaced with the home directory of the given user.</p>

<p>For more information please consult the <a href=
'http://localhost:1313/tcl/tclx/Translate.3.html'>Translate(3)</a> manual page in the core Tcl
distribution.</p>

<h2><a name='sect27' href='ObjCmdWrite.3.html#toc27'><b>Setting</b> <b>the</b>
<b>Recursion</b> <b>Limit</b></a></h2>

<p>Tcl has a preset recursion limit that limits the maximum
allowable nesting depth of calls within an interpreter. This is
useful for detecting infinite recursions before other limits such
as the process memory limit or, worse, available swap space on the
system, run out.</p>

<p>The default limit is just a guess, however, and applications
that make heavy use of recursion may need to call
<b>Tcl_SetRecursionLimit</b> to raise this limit. For more
information, please consult the <a href=
'http://localhost:1313/tcl/tclx/SetRecLmt.3.html'>SetRecLmt(3)</a> man-ual page in the core Tcl
distribution.</p>

<h2><a name='sect28' href='ObjCmdWrite.3.html#toc28'><b>Handling</b> <b>Signals</b>
<b>from</b> <b>Tcl</b> <b>Extensions</b></a></h2>

<p>If an event such as a signal occurs while a Tcl script is being
exe-cuted, it isn&acirc;&euro;&trade;t safe to do much in the
signal handling routine -- the Tcl environment cannot be safely
manipulated at this point because it could be in the middle of some
operation, such as updating pointers, leaving the interpreter in an
unreliable state.</p>

<p>The only safe approach is to set a flag indicating that the
event occurred, then handle the event later when the interpreter
has returned to a safe state, such as after the current Tcl command
completes.</p>

<p>The <b>Tcl_AsyncCreate</b>, <b>Tcl_AsyncMark</b>,
<b>Tcl_AsyncInvoke</b>, and <b>Tcl_AsyncDelete</b> functions
provide a safe mechanism for dealing with signals and other
asynchronous events. For more information on how to use this
capability, please refer to the <a href='http://localhost:1313/tcl/tclx/Async.3.html'>Async(3)</a>
manual page in the core Tcl distribution.</p>

<p>Note that Extended Tcl provides built-in support for managing
signals in numerous ways, including generating them with <a href=
'http://localhost:1313/tcl/tclx/alarm.2.html'>alarm(2)</a> and <a href='http://localhost:1313/tcl/tclx/kill.2.html'>kill(2)</a> ,
ignoring them, trapping them, getting, setting, blocking and
unblocking them. You can cause specific code to execute at a safe
point after a signal occurs, or cause a Tcl error backtrace on
one&acirc;&euro;&trade;s occurrence. For more information, please
examine the TclX documentation.</p>

<h2><a name='sect29' href='ObjCmdWrite.3.html#toc29'><b>Parsing</b> <b>Backslash</b>
<b>Sequences</b></a></h2>

<p>The <b>Tcl_Backslash</b> function is called to parse Tcl
backslash sequences. These backslash sequences are the usual sort
that you see in the C pro-gramming language, such as <b>\n</b> for
newline, <b>\r</b> for return, and so forth. <b>Tcl_Backslash</b>
parses a single backslash sequence and returns a single character
corresponding to the backslash sequence.</p>

<p>For more info on this call, look at the <a href=
'http://localhost:1313/tcl/tclx/Backslash.3.html'>Backslash(3)</a> manual page in the core Tcl
distribution. For information on the valid backslash sequences,
consult the summary of Tcl language syntax, <a href=
'http://localhost:1313/tcl/tclx/Tcl.n.html'>Tcl(n)</a> in the same distribution.</p>

<h2><a name='sect30' href='ObjCmdWrite.3.html#toc30'><b>Hash</b>
<b>Tables</b></a></h2>

<p><i>Hash</i> <i>tables</i> provide Tcl with a high-performance
facility for looking up and managing key-value pairs located and
maintained in memory. Tcl uses hash tables internally to locate
procedure definitions, Tcl vari-ables, array elements, file handles
and so forth. Tcl makes the hash table functions accessible to C
extension writers as well.</p>

<p>Hash tables grow automatically to maintain efficiency, rather
than exposing the table size to the programmer at allocation time,
which would needlessly add complexity to Tcl and would be prone to
ineffi-ciency due to the need to guess the number of items that
will go into the table, and the seemingly inevitable growth in
amount of data pro-cessed per run over the useful life of the
program.</p>

<p>For more information on hash tables, please consult the <a href=
'http://localhost:1313/tcl/tclx/Hash.3.html'>Hash(3)</a> manual page in the core Tcl
distribution.</p>

<h2><a name='sect31' href='ObjCmdWrite.3.html#toc31'><b>Tracing</b> <b>Variable</b>
<b>Accesses</b></a></h2>

<p>The C extension writer can arrange to have a C routine called
whenever a Tcl variable is read, written, or unset. Variable traces
are the mechanism by which Tk toolkit widgets such as radio and
checkbuttons, messages and so forth update without Tcl programmer
intervention when their data variables are changed. They are also
used by the routine that links Tcl and C variables,
<b>Tcl_LinkVar</b>, described above.</p>

<p><b>Tcl_TraceVar</b> is called to establish a variable trace.
Entire arrays and individual array elements can be traced as well.
If the programmer already has an array name in one string and a
variable name in another, <b>Tcl_TraceVar2</b> can be called. Calls
are also available to request information about traces and to
delete them.</p>

<p>For more information on variable traces, consult the <a href=
'http://localhost:1313/tcl/tclx/TraceVar.3.html'>TraceVar(3)</a> manual page in the core Tcl
distribution.</p>

<h2><a name='sect32' href='ObjCmdWrite.3.html#toc32'><b>Tracing</b> <b>Tcl</b>
<b>Execution</b></a></h2>

<p>Tcl has the ability to call C routines each time it executes a
Tcl com-mand, up to a specified depth of nesting levels. The
command <b>Tcl_Cre-ateTrace</b> creates an execution trace;
<b>Tcl_DeleteTrace</b> deletes it.</p>

<p>Command tracing is used in Extended Tcl to implement the
<i>cmdtrace</i> Tcl command, a useful command for debugging Tcl
applications.</p>

<p>For complete information on execution tracing, please look at
the <a href='http://localhost:1313/tcl/tclx/Crt-Trace.3.html'>Crt-Trace(3)</a> manual pages in the
core Tcl distribution.</p>

<h2><a name='sect33' href='ObjCmdWrite.3.html#toc33'><b>Evaluating</b> <b>Tcl</b>
<b>Expressions</b> <b>from</b> <b>C</b></a></h2>

<p><b>Tcl_ExprLong</b>, <b>Tcl_ExprDouble</b>, <b>Tcl_ExprBool</b>,
and <b>Tcl_ExprString</b> all take string arguments and, when
called, evaluate those strings as Tcl expressions. Depending on the
routine called, the result is either a C <i>long</i>, a
<i>double</i>, a boolean (<i>int</i> with a value of <b>0</b> or
<i>1</i>), or a <i>char</i> <i>*</i> (obtainable through
<b>Tcl_GetResult</b>).</p>

<p>To take advantage of the performance gains available through the
byte-code compiler, <b>Tcl_ExprLongObj</b>,
<b>Tcl_ExprDoubleObj</b>, <b>Tcl_ExprBoolObj</b>, and
<b>Tcl_ExprObj</b> all take an object containing an expression to
be evaluated (rather than a string.) The result is that
bytecode-compiled version of the expression will be kept in the
object, alongside the string rep-resentation. If the expression is
evaluated again, without being changed, it does not have to be
recompiled... a major performance win.</p>

<p>For complete information on evaluating Tcl expressions from C,
you are invited to examine the <a href=
'http://localhost:1313/tcl/tclx/ExprLong.3.html'>ExprLong(3)</a> and <a href=
'http://localhost:1313/tcl/tclx/ExprLongObj.3.html'>ExprLongObj(3)</a> manpages in the core Tcl
distribution.</p>

<h2><a name='sect34' href='ObjCmdWrite.3.html#toc34'><b>Pattern</b>
<b>Matching</b></a></h2>

<p>The <b>Tcl_StringMatch</b> function can be called to see if a
string matches a specified pattern. <b>Tcl_StringMatch</b> is
called by the Tcl <i>string</i> <i>match</i> command, so the format
for patterns is identical. The pattern format is similar to the one
used by the C-shell; <a href='http://localhost:1313/tcl/tclx/string.n.html'>string(n)</a>
describes this format.</p>

<p>More information about <b>Tcl_StringMatch</b> is available in
the <a href='http://localhost:1313/tcl/tclx/StrMatch.3.html'>StrMatch(3)</a> manpage in the core
Tcl distribution.</p>

<h2><a name='sect35' href='ObjCmdWrite.3.html#toc35'><b>Regular</b> <b>Expression</b>
<b>Pattern</b> <b>Matching</b></a></h2>

<p><b>Tcl_RegExpMatch</b> can be called to determine whether a
string matches a regular expression. <b>Tcl_RegExpMatch</b> is used
internally by the <i>regexp</i> Tcl command.</p>

<p>As regular expressions are typically compiled before use, a
fairly involved process, Tcl also supports routines that separate
the compila-tion of an expression from its use:
<b>Tcl_RegExpCompile</b>, <b>Tcl_RegExpExec</b>, and
<b>Tcl_RegExpRange</b>. If an expression is going to be matched
many times, doing the compile once and caching the compiled regular
expres-sion result, then reusing the cached version by using
<b>Tcl_RegExpExec</b>, can be a significant performance win.</p>

<p>For more information on this function, please consult the <a
href='http://localhost:1313/tcl/tclx/RegExp.3.html'>RegExp(3)</a> manpage in the core Tcl
distribution.</p>

<h2><a name='sect36' href='ObjCmdWrite.3.html#toc36'><b>Manipulating</b> <b>Tcl</b>
<b>Lists</b> <b>from</b> <b>C</b> <b>Extensions</b></a></h2>

<p>The C extension writer often needs to create, manipulate and
decompose Tcl lists. <b>Tcl_SplitList</b> and <b>Tcl_Merge</b> used
to be the only way to parse strings into lists and vice versa. As
of Tcl 8, lists can be parsed and assembled, object-style, using
<b>Tcl_ListObjGetElements</b> and <b>Tcl_SetListObj</b>, and
friends. Once again the win of using object-sys-tem-based list
manipulation, instead of the previous string based rou-tines, is
that the parsing of a string in an object to a list is cached in
the object structure, the same as with integers and floating point
numbers, compiled procedures, etc. The next time this string needs
to be looked at as a list, if the contents of the string have not
changed, the string does not have to be parsed.</p>

<p>In the author&acirc;&euro;&trade;s experience, working with an
admittedly degenerate test whereby we iterated rather inefficiently
across a 6,000-element list, a speedup factor of more than 2500 was
obtained over the previous non-object-based version of Tcl.</p>

<p>For more information on these commands, please consult the <a
href='http://localhost:1313/tcl/tclx/ListObj.3.html'>ListObj(3)</a> manual page in the core Tcl
distribution.</p>

<h2><a name='sect37' href='ObjCmdWrite.3.html#toc37'><b>Concatenating</b>
<b>Strings</b></a></h2>

<p><b>Tcl_ConcatObj</b> concatenates the string representation of
zero or more objects into a single new object. The elements of the
new string are space-separated. <b>Tcl_Concat</b> does the same
thing for strings, as <b>Tcl_ConcatObj</b> does for objects.</p>

<p>Concatenating strings is similar to constructing lists from
them, except that <b>Tcl_ConcatObj</b> and <b>Tcl_Concat</b> do not
attempt to make the resulting string into a valid Tcl list.</p>

<p><b>Tcl_Concat</b> is documented in the <a href=
'http://localhost:1313/tcl/tclx/Concat.3.html'>Concat(3)</a> manpage, and <b>Tcl_ConcatObj</b> in
the <b>tringObj</b> manpage, both in the core Tcl distribution.</p>

<h2><a name='sect38' href='ObjCmdWrite.3.html#toc38'><b>Detecting</b> <b>Whether</b>
<b>or</b> <b>Not</b> <b>You</b> <b>Have</b> <b>a</b>
<b>Complete</b> <b>Command</b></a></h2>

<p>C routines that collect data to form a command to be passed to
<i>Tcl</i><b>_</b><i>Eval</i> often need a way to tell whether they
have a complete command already or whether they need more data.
(Programs that read typed-in Tcl input such as Tcl shells need this
capability, for instance.) <b>Tcl_Command-Complete</b> can be used
to tell whether or not you have a complete com-mand.</p>

<p>For more information examine <a href=
'http://localhost:1313/tcl/tclx/CmdCmplt.3.html'>CmdCmplt(3)</a> in the core Tcl distribution.</p>

<h2><a name='sect39' href='ObjCmdWrite.3.html#toc39'><b>Recording</b> <b>Commands</b>
<b>for</b> <b>Command</b> <b>History</b></a></h2>

<p>Tcl has a history mechanism that is accessed from Tcl through
the <i>his-tory</i> command. If you want your extension to
propagate commands into the command history, you should call
<i>Tcl</i><b>_</b><i>RecordAndEvalObj</i> (object sys-tem) or
<i>Tcl</i><b>_</b><i>RecordAndEval</i> (old system),</p>

<p>These commands work like <i>Tcl</i><b>_</b><i>EvalObj</i> and
<i>Tcl</i><b>_</b><i>Eval</i>, respectively, except that these
versions record the command as well as executing it.</p>

<p><i>Tcl</i><b>_</b><i>RecordAndEval</i> and
<i>Tcl</i><b>_</b><i>RecordAndEvlObj</i> should only be called with
user-entered top-level commands, since the history mechanism exists
to allow the user to easily access, edit and reissue previously
issued commands.</p>

<p>For complete information on these functions, please examine the
<b>RecordEval</b>.3 and <b>RecEvalObj</b>.3 manual pages in the
core Tcl distribu-tion.</p>

<h2><a name='sect40' href='ObjCmdWrite.3.html#toc40'><b>Converting</b>
<b>Floating</b> <b>Point</b> <b>Values</b> <b>to</b>
<b>Strings</b></a></h2>

<p>The Tcl object system&acirc;&euro;&trade;s
<b>Tcl_GetDoubleFromObj</b> and <b>Tcl_SetDoubleObj</b> use Tcl
objects, rather than the strings used by <b>Tcl_PrintDouble</b>,
and con-vert, when necessary, an ASCII string to a <i>double</i>
and back again.</p>

<p>These routines ensure that the string output will continue to be
inter-pretable as a floating point number, rather than an integer,
by always putting a
&acirc;&euro;&tilde;&acirc;&euro;&tilde;.&acirc;&euro;&trade;&acirc;&euro;&trade;
or
&acirc;&euro;&tilde;&acirc;&euro;&tilde;e&acirc;&euro;&trade;&acirc;&euro;&trade;
into the string representing the number.</p>

<p>The precision of the output string is controlled by the Tcl
<b>tcl_preci-sion</b> variable.</p>

<p>For complete information on these routines, please examine <a
href='http://localhost:1313/tcl/tclx/DoubleObj.3.html'>DoubleObj(3)</a> and <a href=
'http://localhost:1313/tcl/tclx/PrintDbl.3.html'>PrintDbl(3)</a> in the core Tcl distribution.</p>

<h2><a name='sect41' href='ObjCmdWrite.3.html#toc41'><b>Creating</b> <b>Child</b>
<b>Processes</b> <b>and</b> <b>Pipelines</b> <b>from</b>
<b>C</b></a></h2>

<p><b>Tcl_OpenCommandChannel</b> provides a C-level interface to
the <b>exec</b> and <b>open</b> commands. The child (or pipeline of
children) can have its stan-dard input, output and error redirected
from files, variables or pipes. To understand the meaning of the
redirection symbols understood by this function, look at the <a
href='http://localhost:1313/tcl/tclx/exec.n.html'>exec(n)</a> Tcl command. For complete
information on <b>Tcl_OpenCommandChannel</b>, please examine <a
href='http://localhost:1313/tcl/tclx/OpenFileChnl.3.html'>OpenFileChnl(3)</a> .</p>

<h2><a name='sect42' href='ObjCmdWrite.3.html#toc42'><b>Accessing</b> <b>Tcl</b>
<b>Filehandles</b> <b>from</b> <b>C</b></a></h2>

<p>On Posix/Unix systems, Tcl filehandles passed to your C
extension can be translated to a Posix <i>FILE</i> <i>*</i>
structure using the <b>Tcl_GetOpenFile</b> function, documented in
<b>GetOpnFl</b>.3.</p>

<h2><a name='sect43' href='ObjCmdWrite.3.html#toc43'><b>Managing</b>
<b>Background</b> <b>Process</b> <b>Termination</b> <b>and</b>
<b>Cleanup</b></a></h2>

<p>When a Posix system does a <i>fork</i> to create a new process,
the process ID of the child is returned to the caller. After the
child process exits, its process table entry (and some other data
associated with the pro-cess) cannot be reclaimed by the operating
system until a call to <i>wait-pid</i>, or one of a couple of
other, similar system calls, has been made by the parent
process.</p>

<p>The C extension writer who has created a subprocess, by whatever
mecha-nism, can turn over responsibility for detecting the
processes&acirc;&euro;&trade; termi-nation and calling
<i>waitpid</i> to obtain its exit status, by calling
<b>Tcl_DetachPids</b> on it.</p>

<p><b>Tcl_ReapDetachedProcs</b> is the C routine that will detect
the termination of any processes turned over to Tcl, permitting the
processes to be fully reclaimed by the operating system. It is
usually not necessary to call <b>Tcl_ReapDetachedProcs</b>, as it
is called automatically every time <b>exec</b> is performed.</p>

<p>For complete information on these routines, please look at
<i>Detach-Pids(3)</i> in the core Tcl distribution.</p>

<h2><a name='sect44' href='ObjCmdWrite.3.html#toc44'><b>for</b> <b>More</b>
<b>Information</b></a></h2>

<p>In addition to the documentation referenced above, you can learn
a lot by studying the source code of the commands added by Tcl, Tk
and Extended Tcl, etc. The <i>comp.lang.tcl</i> Usenet newsgroup is
read by hun-dreds of thousands of Tcl people. A number of
Frequently Asked Ques-tions (FAQs) about Tcl are posted there
periodically. The newsgroup is a good place to ask questions (after
you&acirc;&euro;&trade;ve made sure they&acirc;&euro;&trade;re not
already answered in the FAQ ;-)</p>

<p>Finally, if you have interactive Internet access, you can ftp to
<i>ftp://ftp.neosoft.com/pub/tcl</i>, the site for contributed Tcl
sources. This site contains quite a few extensions, applications,
and so forth, including several object-oriented extension
packages.</p>

<p>If you have access via the world-wide web, check out the Sun
Microsys-tems site (<i>http://sunscript.sun.com</i>), the
contributed sources archive website
(<i>http://www.neosoft.com/tcl</i>), and the homepage for Extended
Tcl (<i>http://www.neosoft.com/tclx</i>).</p>

<h2><a name='sect45' href='ObjCmdWrite.3.html#toc45'><b>Authors</b></a></h2>

<p>Extended Tcl was created by Karl Lehenbauer (karl@neosoft.com)
and Mark Diekhans (markd@grizzly.com).</p>

<h2><a name='sect46' href='ObjCmdWrite.3.html#toc46'>Tcl Command
Writing(TCL)</a></h2>

<hr>
<p><a name='toc'><b>Table of Contents</b></a></p>

<ul>
<li><a name='toc0' href='ObjCmdWrite.3.html#sect0'>Name</a></li>

<li><a name='toc1' href='ObjCmdWrite.3.html#sect1'>Overview</a></li>

<li><a name='toc2' href='ObjCmdWrite.3.html#sect2'>Tcl Object System</a></li>

<li><a name='toc3' href='ObjCmdWrite.3.html#sect3'>a Simple C Extension</a></li>

<li><a name='toc4' href='ObjCmdWrite.3.html#sect4'>Interpreters</a></li>

<li><a name='toc5' href='ObjCmdWrite.3.html#sect5'>Object Count and
Arguments</a></li>

<li><a name='toc6' href='ObjCmdWrite.3.html#sect6'>Returning Results</a></li>

<li><a name='toc7' href='ObjCmdWrite.3.html#sect7'>Validating Arguments</a></li>

<li><a name='toc8' href='ObjCmdWrite.3.html#sect8'>Another C Extension - the Max
Command</a></li>

<li><a name='toc9' href='ObjCmdWrite.3.html#sect9'>Returning Results</a></li>

<li><a name='toc10' href='ObjCmdWrite.3.html#sect10'>Another C Extension - the
Lreverse Command</a></li>

<li><a name='toc11' href='ObjCmdWrite.3.html#sect11'>Installing Your Command</a></li>

<li><a name='toc12' href='ObjCmdWrite.3.html#sect12'>Dynamic Strings</a></li>

<li><a name='toc13' href='ObjCmdWrite.3.html#sect13'>Client Data</a></li>

<li><a name='toc14' href='ObjCmdWrite.3.html#sect14'>Theory of Handles</a></li>

<li><a name='toc15' href='ObjCmdWrite.3.html#sect15'>Using Commands to Do the Same
Thing, and More</a></li>

<li><a name='toc16' href='ObjCmdWrite.3.html#sect16'>Tracking Memory Corruption
Problems</a></li>

<li><a name='toc17' href='ObjCmdWrite.3.html#sect17'>Installing Your Extensions into
Tcl</a></li>

<li><a name='toc18' href='ObjCmdWrite.3.html#sect18'>GNU Autoconf</a></li>

<li><a name='toc19' href='ObjCmdWrite.3.html#sect19'>Making Application Information
Visible from Extended Tcl</a></li>

<li><a name='toc20' href='ObjCmdWrite.3.html#sect20'>Extended Tcl Exit</a></li>

<li><a name='toc21' href='ObjCmdWrite.3.html#sect21'>Executing Tcl Code from Your C
Extension</a></li>

<li><a name='toc22' href='ObjCmdWrite.3.html#sect22'>Accessing Tcl Variables and
Arrays from Your C Extensions</a></li>

<li><a name='toc23' href='ObjCmdWrite.3.html#sect23'>Linking Tcl Variables to C
Variables</a></li>

<li><a name='toc24' href='ObjCmdWrite.3.html#sect24'>Adding New Math Functions to
Tcl</a></li>

<li><a name='toc25' href='ObjCmdWrite.3.html#sect25'>Accessing and Manipulating the
Random Number Generator</a></li>

<li><a name='toc26' href='ObjCmdWrite.3.html#sect26'>Converting Filenames to Native
Form and Performing Tilde Substitutions</a></li>

<li><a name='toc27' href='ObjCmdWrite.3.html#sect27'>Setting the Recursion
Limit</a></li>

<li><a name='toc28' href='ObjCmdWrite.3.html#sect28'>Handling Signals from Tcl
Extensions</a></li>

<li><a name='toc29' href='ObjCmdWrite.3.html#sect29'>Parsing Backslash
Sequences</a></li>

<li><a name='toc30' href='ObjCmdWrite.3.html#sect30'>Hash Tables</a></li>

<li><a name='toc31' href='ObjCmdWrite.3.html#sect31'>Tracing Variable
Accesses</a></li>

<li><a name='toc32' href='ObjCmdWrite.3.html#sect32'>Tracing Tcl Execution</a></li>

<li><a name='toc33' href='ObjCmdWrite.3.html#sect33'>Evaluating Tcl Expressions from
C</a></li>

<li><a name='toc34' href='ObjCmdWrite.3.html#sect34'>Pattern Matching</a></li>

<li><a name='toc35' href='ObjCmdWrite.3.html#sect35'>Regular Expression Pattern
Matching</a></li>

<li><a name='toc36' href='ObjCmdWrite.3.html#sect36'>Manipulating Tcl Lists from C
Extensions</a></li>

<li><a name='toc37' href='ObjCmdWrite.3.html#sect37'>Concatenating Strings</a></li>

<li><a name='toc38' href='ObjCmdWrite.3.html#sect38'>Detecting Whether or Not You
Have a Complete Command</a></li>

<li><a name='toc39' href='ObjCmdWrite.3.html#sect39'>Recording Commands for Command
History</a></li>

<li><a name='toc40' href='ObjCmdWrite.3.html#sect40'>Converting Floating Point Values
to Strings</a></li>

<li><a name='toc41' href='ObjCmdWrite.3.html#sect41'>Creating Child Processes and
Pipelines from C</a></li>

<li><a name='toc42' href='ObjCmdWrite.3.html#sect42'>Accessing Tcl Filehandles from
C</a></li>

<li><a name='toc43' href='ObjCmdWrite.3.html#sect43'>Managing Background Process
Termination and Cleanup</a></li>

<li><a name='toc44' href='ObjCmdWrite.3.html#sect44'>for More Information</a></li>

<li><a name='toc45' href='ObjCmdWrite.3.html#sect45'>Authors</a></li>

<li><a name='toc46' href='ObjCmdWrite.3.html#sect46'>Tcl Command
Writing(TCL)</a></li>
</ul>
</body>
</html>



			<aside class="copyright" role="note">
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				<div class="as_footer">
  
  <div class="prod_links">
    <strong>
    <a href="http://www.activestate.com/downloads" target="_blank">Downloads</a>&nbsp;&nbsp;
    <a href="http://store.activestate.com" target="_blank">Store</a>&nbsp;&nbsp;
    <a href="http://community.activestate.com" target="_blank">Community</a>&nbsp;&nbsp;
    <a href="http://code.activestate.com" target="_blank">Code</a>&nbsp;&nbsp;
    <a href="http://bugs.activestate.com" target="_blank">Bugzilla</a>
  </strong>
  </div>
  <div class="as_copyright"> 
    &copy; 2017 ActiveState Software Inc. All rights reserved. <strong><a href="../../trademarks/index.html">Trademarks</a></strong>.
  </div>
</div>

			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '';
      var repo_id  = '';
    
    </script>

    <script src="../../javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "";
            headers[i].appendChild(a);
        }
      }
    </script>

    

    

  </body>
</html>

